---
title: Day 1
description: Prerequisites ‚Äî JavaScript basics and core React concepts.
---

<InlineTOC items={toc} />

<div className='mt-8'>

# JavaScript Basics

## Variables 

Variables are containers that store data values and allow us to reuse them throughout our code.

### Variable Declaration

There are two main ways to declare variables:

#### 1. `const` - Immutable Variables
We use the `const` keyword when we want to create a variable whose value **cannot be changed**.

```javascript
const userName = "John Doe";
// userName = "Jane"; // ‚ùå This would cause an error
```

#### 2. `let` - Mutable Variables  
We use the `let` keyword when we want to create a variable whose value **can be changed**.

```javascript
let userAge = 30;
userAge = 31; // ‚úÖ This is allowed
```

### Identifier Rules

Variable names (identifiers) must follow these rules:

1. **Must start with** a letter, underscore (_), or dollar sign ($)
2. **Cannot start** with a number (0-9)
3. **Case-sensitive** (`userName` ‚â† `username`)
4. **Cannot use** reserved keywords (`let`, `const`, `function`, etc.)

**Examples:**
```javascript
// ‚úÖ Valid identifiers
const firstName = "John";
let _privateVar = "secret";
let $element = "myElement";

// ‚ùå Invalid identifiers
// const 2names = "invalid";  // starts with number
// let function = "invalid";   // reserved keyword
```

---

## Functions

Functions are blocks of instructions grouped together to perform a specific task. They're reusable pieces of code that can be called multiple times.

### Function Declaration

```javascript
function add(a, b) {
    return a + b;
}

// Function Call
add(2, 3); // Returns 5
```

**Terminology:**
- **Parameters**: `a, b` - placeholders in the function definition
- **Arguments**: `2, 3` - actual values passed when calling the function

### Function Expression

When you store a function in a variable:

```javascript
const add = function(a, b) {
    return a + b;
};

// Function Call
add(2, 3); // Returns 5
```

### Arrow Function

A shorter, modern syntax for writing functions:

```javascript
const add = (a, b) => {
    return a + b;
};

// Even shorter for single expressions:
const addShort = (a, b) => a + b;

// Function Call
add(2, 3); // Returns 5
```

---

## Conditional Statements and Ternary Operator

### Conditional Statements

Conditional statements are used to perform different actions based on different conditions.

```javascript
const age = 18;
if (age >= 18) {
    console.log("You are an adult.");
} else {
    console.log("You are a minor.");
}
```

### Ternary Operator

The ternary operator is a shorthand for simple if-else statements. It takes three operands and follows the pattern: `condition ? valueIfTrue : valueIfFalse`

```javascript
const age = 18;
const status = (age >= 18) ? "Adult" : "Minor";
console.log(status); // Output: "Adult"
```

---

## Arrays

An array is a special variable that can hold more than one value at a time. The items in an array can be accessed using their index (starting from 0).

```javascript
const fruits = ["Apple", "Banana", "Cherry"];
console.log(fruits[0]); // Output: "Apple"
console.log(fruits[1]); // Output: "Banana"
```

### Nested Arrays

An array can contain other arrays as its elements. This is called a nested array.

```javascript
const nestedArray = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
console.log(nestedArray[0][1]); // Output: 2
```

### Combining Arrays

```javascript
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];

// Method 1: Spread operator (modern approach)
const combinedArray1 = [...array1, ...array2];
console.log(combinedArray1); // Output: [1, 2, 3, 4, 5, 6]

// Method 2: concat() method
const combinedArray2 = array1.concat(array2);
console.log(combinedArray2); // Output: [1, 2, 3, 4, 5, 6]
```

### Array Methods and Properties

#### Basic Properties and Methods

```javascript
const fruits = ["Apple", "Banana", "Cherry"];

// Length property
console.log(fruits.length); // Output: 3

// push() - Adds element to the end
fruits.push("Orange");
console.log(fruits); // Output: ["Apple", "Banana", "Cherry", "Orange"]

// pop() - Removes the last element
fruits.pop();
console.log(fruits); // Output: ["Apple", "Banana", "Cherry"]

// unshift() - Adds element to the beginning
fruits.unshift("Mango");
console.log(fruits); // Output: ["Mango", "Apple", "Banana", "Cherry"]

// shift() - Removes the first element
fruits.shift();
console.log(fruits); // Output: ["Apple", "Banana", "Cherry"]

// reverse() - Reverses the order of elements
fruits.reverse();
console.log(fruits); // Output: ["Cherry", "Banana", "Apple"]
```

#### Search and Check Methods

```javascript
const fruits = ["Apple", "Banana", "Cherry"];

// includes() - Checks if array contains a value
console.log(fruits.includes("Banana")); // Output: true
console.log(fruits.includes("Mango"));  // Output: false

// indexOf() - Returns index of element, -1 if not found
console.log(fruits.indexOf("Banana")); // Output: 1
console.log(fruits.indexOf("Mango"));  // Output: -1
```

#### Array Slicing and Splicing

```javascript
// slice() - Returns a portion without changing the original
const fruits = ["apple", "banana", "cherry", "date"];
const slicedFruits = fruits.slice(1, 3); 
console.log(slicedFruits); // Output: ["banana", "cherry"]
console.log(fruits); // Original: ["apple", "banana", "cherry", "date"]

// splice() - Changes array by adding/removing/replacing items
const fruits2 = ["apple", "banana", "cherry", "date"];

// Remove 1 item at index 1
const removed = fruits2.splice(1, 1);
console.log(removed); // Output: ["banana"]
console.log(fruits2); // Output: ["apple", "cherry", "date"]

// Add items at index 2
fruits2.splice(2, 0, "mango", "kiwi");
console.log(fruits2); // Output: ["apple", "cherry", "mango", "kiwi", "date"]

// Replace 1 item at index 0
fruits2.splice(0, 1, "grape");
console.log(fruits2); // Output: ["grape", "cherry", "mango", "kiwi", "date"]
```

### Advanced Array Methods

#### map() - Transform Elements

Creates a new array with the results of calling a function on every element.

```javascript
const fruits = ["Apple", "Banana", "Cherry"];
const upperCaseFruits = fruits.map(fruit => fruit.toUpperCase());
console.log(upperCaseFruits); // Output: ["APPLE", "BANANA", "CHERRY"]

const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num => num * 2);
console.log(doubled); // Output: [2, 4, 6, 8, 10]
```

#### filter() - Filter Elements

Creates a new array with all elements that pass a test function.

```javascript
const fruits = ["Apple", "Banana", "Cherry"];
const bFruits = fruits.filter(fruit => fruit.startsWith("B"));
console.log(bFruits); // Output: ["Banana"]

const numbers = [1, 2, 3, 4, 5, 6];
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // Output: [2, 4, 6]
```

#### reduce() - Reduce to Single Value

Executes a reducer function on each element, resulting in a single output value.

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const sum = numbers.reduce((previousValue, currentValue) => {
    return previousValue + currentValue;
}, 0);
console.log(sum); // Output: 55

// Shorter version
const sum2 = numbers.reduce((prev, curr) => prev + curr, 0);
console.log(sum2); // Output: 55
```

---

## Objects

An object is a collection of key-value pairs, where each key is a string (property name) and the value can be any data type.

### Basic Object Operations

```javascript
const person = {
    name: "Alex",
    age: 25,
    city: "Bangalore"
};  

// Accessing values
console.log(person.name);        // "Alex" (dot notation)
console.log(person["city"]);     // "Bangalore" (bracket notation)

// Adding a new property
person.country = "India";

// Updating a property
person.age = 26;

// Deleting a property
delete person.city;

console.log(person);
// Output: { name: "Alex", age: 26, country: "India" }
```

### Nested Objects

An object can contain other objects as its properties.

```javascript
const person = {
    name: "Alex",
    age: 25,
    address: {
        street: "123 Main St",
        city: "Bangalore",
        country: "India"
    }
};

// Accessing nested object properties
console.log(person.address.city); // Output: "Bangalore"
console.log(person.address.street); // Output: "123 Main St"
```

### Combining Objects

```javascript
const person1 = {
    name: "Alex",
    age: 25,
    gender: "Male"
};

const person2 = {
    name: "Sam",
    age: 20,
    gender: "Female"
};

// Method 1: Create object containing both objects
const users = { person1, person2 };
console.log(users);
// Output: { 
//   person1: { name: "Alex", age: 25, gender: "Male" }, 
//   person2: { name: "Sam", age: 20, gender: "Female" } 
// }

// Method 2: Merge properties using spread operator
const mergedPerson = { ...person1, ...person2 };
console.log(mergedPerson);
// Output: { name: "Sam", age: 20, gender: "Female" } (person2 overwrites person1)
```

### Object Destructuring

Destructuring allows you to extract multiple properties from an object at once.

```javascript
const person = {
    name: "Alex",
    age: 25,
    gender: "Male"
};

// Instead of:
// const name = person.name;
// const age = person.age;

// Use destructuring:
const { name, age } = person;
console.log(name); // Output: "Alex"
console.log(age);  // Output: 25

// Destructuring with different variable names
const { name: personName, age: personAge } = person;
console.log(personName); // Output: "Alex"
console.log(personAge);  // Output: 25
```

---

## Practice Exercises

### Exercise 1: Variables and Functions
Create a function that calculates the area of a rectangle:

```javascript
const calculateRectangleArea = (length, width) => {
    return length * width;
};

console.log(calculateRectangleArea(5, 3)); // Should output: 15
```

### Exercise 2: Array Methods
Practice with array methods:

```javascript
const movies = ["Inception", "Interstellar", "The Dark Knight"];

// Add a new movie
movies.push("Dunkirk");

// Filter movies that start with "The"
const theMovies = movies.filter(movie => movie.startsWith("The"));

// Convert all to uppercase
const upperMovies = movies.map(movie => movie.toUpperCase());

console.log(movies);
console.log(theMovies);
console.log(upperMovies);
```

### Exercise 3: Objects and Destructuring
Create and manipulate a student object:

```javascript
const student = {
    name: "John Doe",
    age: 20,
    subjects: ["Math", "Science", "English"],
    address: {
        city: "Mumbai",
        state: "Maharashtra"
    }
};

// Extract name and age using destructuring
const { name, age } = student;

// Extract city from nested address
const { address: { city } } = student;

console.log(`${name} is ${age} years old and lives in ${city}`);
```

---

</div>

<div className='mt-8 mb-8'>
# React Basics

Now that we understand JavaScript fundamentals, let's dive into React concepts. React is a JavaScript library for building user interfaces, and React Native uses the same principles to build mobile applications.

## Components

Components are the building blocks of React applications. Think of them as custom HTML elements that you can reuse throughout your application.

### What is a Component?

A component is a JavaScript function or class that returns JSX (which describes what the UI should look like). Components let you split the UI into independent, reusable pieces.

### Function Components

The modern and preferred way to create components:

```javascript
// Basic function component
function Welcome() {
    return <h1>Hello, World!</h1>;
}

// Arrow function component
const Welcome = () => {
    return <h1>Hello, World!</h1>;
};

// Even shorter for simple components
const Welcome = () => <h1>Hello, World!</h1>;
```

### Component Rules

1. **Component names must start with a capital letter**
2. **Components must return JSX**
3. **Components should be pure functions** (same input = same output)

```javascript
// ‚úÖ Correct - starts with capital letter
const UserProfile = () => {
    return <div>User Profile</div>;
};

// ‚ùå Incorrect - starts with lowercase
const userProfile = () => {
    return <div>User Profile</div>;
};
```

### Using Components

```javascript
// Define a component
const Greeting = () => {
    return <h2>Welcome to React!</h2>;
};

// Use the component in another component
const App = () => {
    return (
        <div>
            <Greeting />
            <Greeting />
            <p>This is my app</p>
        </div>
    );
};
```

---

## JSX (JavaScript XML)

JSX is a syntax extension for JavaScript that looks like HTML but is actually JavaScript. It describes what the UI should look like.

### What is JSX?

JSX allows you to write HTML-like syntax directly in your JavaScript code. It gets compiled to regular JavaScript function calls.

```javascript
// JSX
const element = <h1>Hello, World!</h1>;

// Compiles to regular JavaScript
const element = React.createElement('h1', null, 'Hello, World!');
```

### JSX Rules

#### 1. Must Return a Single Parent Element

```javascript
// ‚ùå Incorrect - multiple root elements
const MyComponent = () => {
    return (
        <h1>Title</h1>
        <p>Paragraph</p>
    );
};

// ‚úÖ Correct - wrapped in a single parent
const MyComponent = () => {
    return (
        <div>
            <h1>Title</h1>
            <p>Paragraph</p>
        </div>
    );
};

// ‚úÖ Alternative - using React Fragment
const MyComponent = () => {
    return (
        <>
            <h1>Title</h1>
            <p>Paragraph</p>
        </>
    );
};
```

#### 2. Use `className` instead of `class`

```javascript
// ‚ùå Incorrect - 'class' is a reserved keyword in JavaScript
const MyComponent = () => {
    return <div class="container">Content</div>;
};

// ‚úÖ Correct - use 'className'
const MyComponent = () => {
    return <div className="container">Content</div>;
};
```

#### 3. All Tags Must Be Closed

```javascript
// ‚ùå Incorrect - unclosed tags
const MyComponent = () => {
    return (
        <div>
            <img src="image.jpg">
            <br>
        </div>
    );
};

// ‚úÖ Correct - self-closing tags
const MyComponent = () => {
    return (
        <div>
            <img src="image.jpg" />
            <br />
        </div>
    );
};
```

### JavaScript in JSX

You can embed JavaScript expressions in JSX using curly braces `{}`:

```javascript
const UserCard = () => {
    const name = "John Doe";
    const age = 25;
    const isActive = true;

    return (
        <div>
            <h2>{name}</h2>
            <p>Age: {age}</p>
            <p>Years until 30: {30 - age}</p>
            <p>Status: {isActive ? "Active" : "Inactive"}</p>
            <p>Welcome message: {name.toUpperCase()}</p>
        </div>
    );
};
```

### Conditional Rendering

```javascript
const UserStatus = () => {
    const isLoggedIn = true;
    const user = { name: "John", role: "admin" };

    return (
        <div>
            {/* Conditional rendering with ternary operator */}
            {isLoggedIn ? (
                <h1>Welcome back, {user.name}!</h1>
            ) : (
                <h1>Please log in</h1>
            )}

            {/* Conditional rendering with && operator */}
            {user.role === "admin" && (
                <button>Admin Panel</button>
            )}
        </div>
    );
};
```

### Rendering Lists

```javascript
const MovieList = () => {
    const movies = ["Inception", "Interstellar", "The Dark Knight"];

    return (
        <div>
            <h2>My Favorite Movies</h2>
            <ul>
                {movies.map((movie, index) => (
                    <li key={index}>{movie}</li>
                ))}
            </ul>
        </div>
    );
};

// Better approach with unique keys
const UserList = () => {
    const users = [
        { id: 1, name: "John", email: "john@email.com" },
        { id: 2, name: "Jane", email: "jane@email.com" },
        { id: 3, name: "Bob", email: "bob@email.com" }
    ];

    return (
        <div>
            <h2>Users</h2>
            {users.map(user => (
                <div key={user.id}>
                    <h3>{user.name}</h3>
                    <p>{user.email}</p>
                </div>
            ))}
        </div>
    );
};
```

---

## Props

Props (properties) are how you pass data from parent components to child components. Think of them as function parameters for components.

### Basic Props Usage

```javascript
// Child component that receives props
const Greeting = (props) => {
    return <h1>Hello, {props.name}!</h1>;
};

// Parent component that passes props
const App = () => {
    return (
        <div>
            <Greeting name="John" />
            <Greeting name="Jane" />
            <Greeting name="Bob" />
        </div>
    );
};
```

### Props Destructuring

```javascript
// Instead of using props.name, props.age
const UserCard = (props) => {
    return (
        <div>
            <h2>{props.name}</h2>
            <p>Age: {props.age}</p>
            <p>City: {props.city}</p>
        </div>
    );
};

// Use destructuring for cleaner code
const UserCard = ({ name, age, city }) => {
    return (
        <div>
            <h2>{name}</h2>
            <p>Age: {age}</p>
            <p>City: {city}</p>
        </div>
    );
};

// Using the component
const App = () => {
    return (
        <UserCard 
            name="John Doe" 
            age={25} 
            city="Bangalore" 
        />
    );
};
```

### Different Types of Props

```javascript
const UserProfile = ({ name, age, isActive, hobbies, address }) => {
    return (
        <div>
            <h2>{name}</h2>
            <p>Age: {age}</p>
            <p>Status: {isActive ? "Active" : "Inactive"}</p>
            
            {/* Array prop */}
            <h3>Hobbies:</h3>
            <ul>
                {hobbies.map((hobby, index) => (
                    <li key={index}>{hobby}</li>
                ))}
            </ul>
            
            {/* Object prop */}
            <h3>Address:</h3>
            <p>{address.city}, {address.state}</p>
        </div>
    );
};

// Using the component with different prop types
const App = () => {
    const user = {
        name: "John Doe",
        age: 25,
        isActive: true,
        hobbies: ["reading", "coding", "gaming"],
        address: {
            city: "Bangalore",
            state: "Karnataka"
        }
    };

    return (
        <UserProfile 
            name={user.name}
            age={user.age}
            isActive={user.isActive}
            hobbies={user.hobbies}
            address={user.address}
        />
    );
};
```

### Default Props

```javascript
const Button = ({ text = "Click me", color = "blue", onClick }) => {
    return (
        <button 
            style={{ backgroundColor: color }}
            onClick={onClick}
        >
            {text}
        </button>
    );
};

// Usage
const App = () => {
    return (
        <div>
            <Button /> {/* Uses default text and color */}
            <Button text="Submit" color="green" />
            <Button text="Cancel" color="red" />
        </div>
    );
};
```

### Props are Read-Only

```javascript
// ‚ùå Never modify props directly
const BadComponent = ({ name }) => {
    name = "Modified Name"; // This is wrong!
    return <h1>{name}</h1>;
};

// ‚úÖ Props should be treated as immutable
const GoodComponent = ({ name }) => {
    const displayName = name.toUpperCase(); // Create new variable
    return <h1>{displayName}</h1>;
};
```

---

## State

State is data that belongs to a component and can change over time. Unlike props, state is managed within the component and can be updated.

### useState Hook

The `useState` hook allows functional components to have state.

```javascript
import { useState } from 'react';

const Counter = () => {
    // useState returns [currentValue, setterFunction]
    const [count, setCount] = useState(0);

    const increment = () => {
        setCount(count + 1);
    };

    const decrement = () => {
        setCount(count - 1);
    };

    const reset = () => {
        setCount(0);
    };

    return (
        <div>
            <h2>Count: {count}</h2>
            <button onClick={increment}>+</button>
            <button onClick={decrement}>-</button>
            <button onClick={reset}>Reset</button>
        </div>
    );
};
```

### State with Different Data Types

```javascript
import { useState } from 'react';

const UserForm = () => {
    // String state
    const [name, setName] = useState("");
    
    // Number state
    const [age, setAge] = useState(18);
    
    // Boolean state
    const [isActive, setIsActive] = useState(true);
    
    // Array state
    const [hobbies, setHobbies] = useState([]);
    
    // Object state
    const [user, setUser] = useState({
        firstName: "",
        lastName: "",
        email: ""
    });

    const addHobby = () => {
        const newHobby = "Reading";
        setHobbies([...hobbies, newHobby]);
    };

    const updateUser = () => {
        setUser({
            ...user,
            firstName: "John"
        });
    };

    return (
        <div>
            <h2>User Form</h2>
            <p>Name: {name}</p>
            <p>Age: {age}</p>
            <p>Active: {isActive ? "Yes" : "No"}</p>
            <p>Hobbies: {hobbies.join(", ")}</p>
            
            <input 
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="Enter name"
            />
            
            <button onClick={addHobby}>Add Hobby</button>
            <button onClick={() => setAge(age + 1)}>Increase Age</button>
            <button onClick={() => setIsActive(!isActive)}>Toggle Active</button>
        </div>
    );
};
```

### State Updates are Asynchronous

```javascript
const AsyncCounter = () => {
    const [count, setCount] = useState(0);

    const handleMultipleUpdates = () => {
        // ‚ùå This won't work as expected - only increments by 1
        setCount(count + 1);
        setCount(count + 1);
        setCount(count + 1);
    };

    const handleMultipleUpdatesCorrect = () => {
        // ‚úÖ Use function form for multiple updates
        setCount(prevCount => prevCount + 1);
        setCount(prevCount => prevCount + 1);
        setCount(prevCount => prevCount + 1);
    };

    return (
        <div>
            <h2>Count: {count}</h2>
            <button onClick={handleMultipleUpdates}>
                Bad Multiple Updates
            </button>
            <button onClick={handleMultipleUpdatesCorrect}>
                Good Multiple Updates
            </button>
        </div>
    );
};
```

### Lifting State Up

When multiple components need to share state, move it to their closest common parent.

```javascript
// Parent component that manages shared state
const ShoppingApp = () => {
    const [cartItems, setCartItems] = useState([]);
    const [totalPrice, setTotalPrice] = useState(0);

    const addToCart = (item) => {
        setCartItems([...cartItems, item]);
        setTotalPrice(totalPrice + item.price);
    };

    const removeFromCart = (itemId) => {
        const itemToRemove = cartItems.find(item => item.id === itemId);
        setCartItems(cartItems.filter(item => item.id !== itemId));
        setTotalPrice(totalPrice - itemToRemove.price);
    };

    return (
        <div>
            <ProductList onAddToCart={addToCart} />
            <Cart 
                items={cartItems} 
                total={totalPrice}
                onRemoveItem={removeFromCart} 
            />
        </div>
    );
};

// Child components receive state and functions via props
const ProductList = ({ onAddToCart }) => {
    const products = [
        { id: 1, name: "Laptop", price: 999 },
        { id: 2, name: "Phone", price: 699 }
    ];

    return (
        <div>
            <h2>Products</h2>
            {products.map(product => (
                <div key={product.id}>
                    <span>{product.name} - ${product.price}</span>
                    <button onClick={() => onAddToCart(product)}>
                        Add to Cart
                    </button>
                </div>
            ))}
        </div>
    );
};

const Cart = ({ items, total, onRemoveItem }) => {
    return (
        <div>
            <h2>Cart</h2>
            <p>Total: ${total}</p>
            {items.map(item => (
                <div key={item.id}>
                    <span>{item.name}</span>
                    <button onClick={() => onRemoveItem(item.id)}>
                        Remove
                    </button>
                </div>
            ))}
        </div>
    );
};
```

---

## Practice Exercises

### Exercise 1: Component Creation
Create a `PersonCard` component that displays a person's information:

```javascript
const PersonCard = ({ name, age, profession, image }) => {
    return (
        <div className="person-card">
            <img src={image} alt={name} />
            <h3>{name}</h3>
            <p>Age: {age}</p>
            <p>Profession: {profession}</p>
        </div>
    );
};

// Use it in App component
const App = () => {
    return (
        <div>
            <PersonCard 
                name="John Doe"
                age={30}
                profession="Software Engineer"
                image="https://example.com/john.jpg"
            />
        </div>
    );
};
```

### Exercise 2: State Management
Create a todo list component:

```javascript
import { useState } from 'react';

const TodoList = () => {
    const [todos, setTodos] = useState([]);
    const [inputValue, setInputValue] = useState("");

    const addTodo = () => {
        if (inputValue.trim() !== "") {
            setTodos([...todos, { id: Date.now(), text: inputValue, completed: false }]);
            setInputValue("");
        }
    };

    const toggleTodo = (id) => {
        setTodos(todos.map(todo =>
            todo.id === id ? { ...todo, completed: !todo.completed } : todo
        ));
    };

    const deleteTodo = (id) => {
        setTodos(todos.filter(todo => todo.id !== id));
    };

    return (
        <div>
            <h2>Todo List</h2>
            <input 
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                placeholder="Enter a todo"
            />
            <button onClick={addTodo}>Add Todo</button>
            
            <ul>
                {todos.map(todo => (
                    <li key={todo.id}>
                        <span 
                            style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}
                            onClick={() => toggleTodo(todo.id)}
                        >
                            {todo.text}
                        </span>
                        <button onClick={() => deleteTodo(todo.id)}>Delete</button>
                    </li>
                ))}
            </ul>
        </div>
    );
};
```

### Exercise 3: Props and State Together
Create a `LikeButton` component:

```javascript
import { useState } from 'react';

const LikeButton = ({ initialLikes = 0, postTitle }) => {
    const [likes, setLikes] = useState(initialLikes);
    const [isLiked, setIsLiked] = useState(false);

    const handleLike = () => {
        if (isLiked) {
            setLikes(likes - 1);
            setIsLiked(false);
        } else {
            setLikes(likes + 1);
            setIsLiked(true);
        }
    };

    return (
        <div>
            <h3>{postTitle}</h3>
            <button 
                onClick={handleLike}
                style={{ 
                    backgroundColor: isLiked ? '#ff6b6b' : '#f0f0f0',
                    color: isLiked ? 'white' : 'black'
                }}
            >
                {isLiked ? '‚ù§Ô∏è Liked' : 'ü§ç Like'} ({likes})
            </button>
        </div>
    );
};

const App = () => {
    return (
        <div>
            <LikeButton initialLikes={5} postTitle="My First React Post" />
            <LikeButton initialLikes={12} postTitle="Learning React State" />
        </div>
    );
};
```

---

## Key Takeaways

### Components
- Building blocks of React applications
- Must start with capital letter
- Should be pure functions (predictable output)
- Can be reused throughout the application

### JSX
- HTML-like syntax in JavaScript
- Must return single parent element
- Use `className` instead of `class`
- JavaScript expressions go in curly braces `{}`
- All tags must be closed

### Props
- Pass data from parent to child components
- Read-only (immutable)
- Can be any data type (string, number, object, array, function)
- Use destructuring for cleaner code

### State
- Data that can change over time
- Managed within the component
- Use `useState` hook for functional components
- State updates are asynchronous
- Lift state up for shared data

These React concepts are fundamental for React Native development. The same principles apply whether you're building web applications with React or mobile applications with React Native!

</div>


# References